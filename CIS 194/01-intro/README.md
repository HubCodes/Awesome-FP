# 01-intro

[From this link](http://www.cis.upenn.edu/~cis194/spring13/lectures/01-intro.html)

## What is Haskell?

### Functional

- 적어도 하스켈에서는 일급 시민으로서 존재하는 함수와, _명령어 실행_ 이 아닌 _식 평가_ 로 이뤄지는 프로그래밍을 의미한다.

### Pure

- No mutation
- No side-effects
- Same input, same output

이것으로 얻을 수 있는 장점들은 다음과 같다.

- 검증 가능한 프로그램과 리팩터링: 대수학에서 배웠듯이 치환하면 된다. 하스켈에서는 "수식에 의한 수식 치환".
- 병렬성: 어떤 코드가 다른 코드에 영향을 미치지 않는 것이 보장되기에, 수식 평가 과정을 병렬화하는 것이 쉽다.
- 적은 두통: 제한되지 않고, 코드 사이의 거리에 구애받지 않는 사이드 이펙트들은 디버그, 유지보수가 힘들고 검증하기 힘든 프로그램을 만들게 한다.

### Lazy

하스켈에서 수식은 그 결과가 필요하기 전까지는 평가되지 않는다. 하지만 이를 이해하는 데는 오랜 시간이 필요하다. 하스켈이 게으르기 때문에 다음과 같은 일들이 일어난다.

- 함수 정의가 곧 새로운 제어 흐름의 정의이다.
- 무한한 크기를 가진 자료구조를 정의하고 사용할 수 있다.
- 하지만 프로그램이 얼마나 시간과 공간을 사용하는 지 추론하는 것은 어려워진다.

### Statically typed

모든 하스켈 식은 타입을 가지고 있다. 그리고 그 타입들은 모두 컴파일 타임에 체크된다. 타입 에러를 가진 소스는 컴파일조차 불가능하다.

### Wholemeal programming

큰 그림을 그려라. 배열을 순회하기 위해 저수준의 인덱스가 중요한 것이 아니라, 배열을 순회하여 얻고자 하는 것이 무엇인가가 중요한 것이다.

```c
int acc = 0;
for (int i = 0; i < lst.length; i++) {
  acc = acc + 3 * lst[i];
}
```

C나 Java 스타일의 프로그래밍 언어라면 이렇게 했을 테지만, 하스켈에서는 다음과 같이 한다.

```haskell
sum (map (3*) lst)
```
